monitor notes:directory structure:These look alot like the UCSD Pascal dir used in Apple ][ Pascal,Described as a variant record structure, they look something like this;Type     DirRecord = Record case boolean of	{ record for master volume header }	True:(	BootSector	:integer;		FirstDataSector	:integer;		unknown		:integer;		VolName		:string[7];	{one lenght byte followed by seven character bytes}		NumberBlocks	:integer;		NumberFiles	:integer;		Unknown		:integer;		VolTimeStamp	:integer);	{ record for file entries}			False:(	StartingSector	:integer;		EndingSector	:Integer;		FileType	:integer	{2:code; 3:text; 5:data}		FileName	:String[15];	{15 bytes of characters preceeded by a length byte}		BytesinLastSector				:integer;		FileTimestamp	:integer)     End; {record}     Note that the True case is two words shorter than the False case, so there are two words of data thatappear to be unsed in master volume header.Using this record, the volume directory is defined as;Type     VolDirectory = Packed Array [0..77] of DirRecord;     Where entery zero (0) is the master volume header and one (1) through seventy seven (77) are the actualfile entries.  This directory size is hard coded in the system anmd cannot be changed.  The volumedirectory occupies four (4) blocks on the disk from block two (2) to block five (5).  Blocks Zero (0) andone (1) are the boot blocks for the volume.	For some reason, a text file in monitor is preceeded by two sectors of extraneous data, perhaps this iswhere the editor stores tab stops, markers and the like.  These two sectors are apparently ignored by thesystem, or at least their use is transparent to the user.  The addition of the sectors makes conversion offiles to text a non-trivial taskTo convert a monitor file to a monitor text type file that can be read by the normal UCSD editor, the following steps must be followed:1:take a fresh monitor disk and K(runch it.  This puts all the free space on the disk at the end of the disk  in one contiguous block.  2:with the new comand, make the file bs.data[2].  This allocates two sectors of the disk from the top of the  new huge block of disk space.  3:copy the file in question to the disk you have just prepared.4:r(emove the file bs.data from the disk.  Note the the [2] is not used5:wuth fedit, go in and change the the pointer to the first sector, so that it points two sectors further  back than before, for example, change a 32 to 30.  Remember that this is in hex.  6:next change the file type to three (3), for a text file7:finally change the name of the file to xxx.text.8:now you should be able to read this file with the editor from monitor.				To look at a file that is not a .text file, you can use the filer function T(rans.  for example to look at the file bootfiles.data you would type T Bootfiles.data,systerm:.(systerm: is the device driver for the screen.)  You can also use console: (another driver for the screen,the big difference between the two is only apparent when getting input from the devices, one echos a keypress while the other does not) or printer:  Be very very careful when trnsferring files to the printer.  Because this does a strait ASCII dump of thefile, if there are any control codes in the file you are transferring, they can consue the printer fataly(software-wise I don't think you could damage the actual hardware this way)Of course, T(rans will also work with a normal text file.